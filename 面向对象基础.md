- 一个 java 源文件可以包含多个类的定义,但只能定义一个 public 类,且 public 类名必须与文件名一致。如果要定义多个 public 类,必须拆到多个 java 源文件中。

* 一个类通过定义方法 就可以给外部代码暴露一些操作的接口,同时内部自己保证逻辑一致性。

定义方法
修饰符 方法返回类型 方法名 (方法参数列表){
若干方法语句
return 方法返回值
}
没有返回值 返回类型设置为 void 可以省略 return

- 引用类型参数的传递 调用方的变量,和接受方的参数变量,指向的是同一个对象。双方任意一方对这个对象的修改,都会影响对方(因为执向同一个对象。)

* 多构造方法 可以定义多个构造方法 在通过 new 操作符调用的时候,编译器通过构造方法的参数数量, 位置 和类型自动区分。

* 方法重载
* 继承 extend super
* 阻止继承 正常情况下,只要某个 class 没有 final 修饰符 那么任何类都可以从该 class 继承
* 从 java15 开始,允许使用 sealed 修饰 class 并通过 permits 明确写出能够从该 class 继承的子类名称。
* 向上转型 Person p = new Student()
* 向下转型

```
Person p = new Student()
if(p instanceof Student){
    // 只有判断成功才会向下转型
    Student s = (Student) p
}

```

- 区分继承和组合

* 在使用继承时,我们要注意逻辑一致性
* 子类和父类的关系是 is has 关系不能用继承
* 在继承管理中 子类如果定义了一个与父类方法签名完全相同的方法,被称为覆写(Override)
* Java 的实例方法调用是基于运行时的实际类型的动态调用,而非变量的声明类型。

* 多态
* 多态是指 针对某个类型的方法调用 其真正执行的方法取决于运行时期实际类型的方法。

* final 修饰方法阻止被覆写 class 阻止被继承 修饰的 field 必须在创建对象时初始化 随后不可修改。

* 抽象类 abstract
* 接口 interface
* 当一个具体带带 class 去实现一个 interface 时,需要使用 implements 关键字
* 一个类可以实现多个 interface
* 一个 interface 可以继承自另外一个 interface。 interface 继承自 interface 使用 extends,它相当于扩展了接口的方法。

* 一般来说 公共逻辑适合放在 abstract class 中 具体逻辑放到各个子类, 而接口层次代表抽象程度。

* 实现类可以不必覆写 defalut 方法。 default 方法的目的是 当我们需要给接口新增一个方法时,会涉及到修改全部子类。如果新增的是 default 方法,那么子类就不必全部修改,只需要在需要覆写的地方覆写新增的方法。
* default 方法和抽象类的普通方法时有所不同的。因为 interface 没有字段 default 方法无法访问字段,而抽象类的普通方法可以访问实例字段。
* 实例字段在每个实例中都有自己的一个独立"空间",但是静态字段只有一个共享"空间",所有实例都会共享该字段。
* 推荐用类名来访问静态字段。可以把静态字段理解为描述 class 本身的字段(非实例字段)。Person.number
* 静态方法 通过类名就可以调用。 静态方法内部无法访问 this 变量 无法访问实例字段,它只能访问静态字段。

* 接口的静态字段
* 因为 interface 是一个纯抽象类 所以它不能定义实例字段。但是 interface 是可以有静态字段的,并且静态字段必须为 final 类型

# OOP base

1. 方法
2. 构造方法
3. 方法重载
4. 继承
5. 多态
6. 抽象类
7. 接口 interface
8. 静态字段和静态方法
9. 包
10. 作用域
11. 内部类
12. calsspath jar
13. class 版本
14. 模块

- 在 java 中我们使用 package 类解决名字冲突。

* java 定义了一种名字空间 称之为包 package。 一个类总是属于某个包,类名(比如 Person )只是简写 真正的完整类名是 包名.类名

* 在定义 class 的时候 我们需要在第一行声明这个 class 属于哪个包

```
package ming  // 申明包名

public class Person{

}

```

- 要特别注意：包没有父子关系。java.util 和 java.util.zip 是不同的包，两者没有任何继承关系。

* 包作用域 位于同一个包的类 可以访问包作用域的字段和方法。 不用 public protected private 修饰的字段 和方法就是包作用域

* 作用域

* 内部类 被定义在另一个类的内部 所以称为内部类 Inner Class、Anonymous Class 和 Static Nested Class

* JVM 通过环境变量 classpath 决定搜索 class 的路径和顺序；

* 不推荐设置系统环境变量 classpath，始终建议通过-cp 命令传入；

* jar 包相当于目录，可以包含很多.class 文件，方便下载和使用；

* MANIFEST.MF 文件可以提供 jar 包的信息，如 Main-Class，这样可以直接运行 jar 包。
* 只要看到 UnsupportedClassVersionError 就表示当前要加载的 class 文件版本超过了 JVM 的能力，必须使用更高版本的 JVM 才能运行。
